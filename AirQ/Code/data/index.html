<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MicKit Live FFT + Audio</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #1e1e1e;
      color: #f0f0f0;
      margin: 0;
      padding: 20px;
      text-align: center;
    }
    h2 { margin-bottom: 5px; }
    .controls { margin: 10px 0; }
    canvas {
      background: #121212;
      border: 1px solid #444;
      display: block;
      margin: 0 auto;
    }
    #peakInfo {
      font-size: 1.4em;
      margin-top: 10px;
      color: #00c8ff;
    }
    audio {
      margin-top: 10px;
      width: 100%;
      max-width: 400px;
    }
  </style>
</head>
<body>
  <h2>ESP32 MicKit â€“ Live FFT + Audio</h2>
  <div class="controls">
    <label><input type="checkbox" id="enableAudio" checked> Enable Audio Playback</label>
  </div>
  <audio id="player" controls autoplay></audio>

  <h3>Live FFT Spectrum</h3>
  <canvas id="fftCanvas" width="900" height="300"></canvas>
  <div id="peakInfo">Peak: -- Hz @ --</div>

  <script>
    const socket = new WebSocket(`ws://${location.host}/audio`);
    const player = document.getElementById("player");
    const fftCanvas = document.getElementById("fftCanvas");
    const ctx = fftCanvas.getContext("2d");
    const peakInfo = document.getElementById("peakInfo");

    let lastFreqs = [];
    let lastMags = [];

    socket.binaryType = "arraybuffer";

    socket.onopen = () => console.log("[WS] Connected");
    socket.onerror = e => console.error("[WS] Error:", e);
    socket.onclose = () => console.warn("[WS] Disconnected");

    socket.onmessage = (event) => {
      if (!(event.data instanceof ArrayBuffer)) return;

      const floatData = new Float32Array(event.data);

      // Identify FFT frame (small) vs WAV audio (large)
      if (floatData.length % 2 === 0 && floatData.length < 10000) {
        const count = floatData.length / 2;
        lastFreqs = new Array(count);
        lastMags = new Array(count);
        for (let i = 0; i < count; i++) {
          lastFreqs[i] = floatData[2 * i];
          lastMags[i] = floatData[2 * i + 1];
        }
      } else if (floatData.length > 10000) {
        if (document.getElementById("enableAudio").checked) {
          const blob = new Blob([event.data], { type: "audio/wav" });
          const url = URL.createObjectURL(blob);
          player.src = url;
          player.play().catch(e => console.warn("[AUDIO] Playback failed:", e));
        }
      }
    };

    function drawFFT() {
      ctx.clearRect(0, 0, fftCanvas.width, fftCanvas.height);
      if (!lastFreqs.length) return;

      const maxMag = Math.max(...lastMags, 0.001);
      const scaleX = fftCanvas.width / lastFreqs.length;
      const scaleY = fftCanvas.height / maxMag;
      const maxFreq = Math.max(...lastFreqs);

      // Draw grid lines and frequency labels
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 1;
      ctx.fillStyle = "#888";
      ctx.font = "10px Arial";
      for (let f = 0; f <= maxFreq; f += 1000) {
        const x = (f / maxFreq) * fftCanvas.width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, fftCanvas.height);
        ctx.stroke();
        ctx.fillText(`${(f / 1000).toFixed(0)}kHz`, x + 2, 12);
      }

      // Draw FFT line
      ctx.beginPath();
      for (let i = 0; i < lastFreqs.length; i++) {
        const x = i * scaleX;
        const y = fftCanvas.height - lastMags[i] * scaleY;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = "#00c8ff";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Peak marker
      const peakIndex = lastMags.indexOf(maxMag);
      const peakFreq = lastFreqs[peakIndex]?.toFixed(1) ?? "--";
      const peakMag = maxMag.toFixed(2);

      const px = peakIndex * scaleX;
      const py = fftCanvas.height - maxMag * scaleY;
      ctx.fillStyle = "#ff4444";
      ctx.beginPath();
      ctx.arc(px, py, 4, 0, 2 * Math.PI);
      ctx.fill();
      ctx.fillText(`${peakFreq}Hz`, px + 5, py - 5);

      peakInfo.textContent = `Peak: ${peakFreq} Hz @ ${peakMag}`;
    }

    function loop() {
      drawFFT();
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
